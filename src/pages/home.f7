<template>
  <div class="page" data-name="home">
    <!-- Top Navbar -->
    <div class="navbar navbar-large navbar-transparent no-outline">
      <div class="navbar-bg"></div>
      <div class="navbar-inner">
        <div class="left">
          <div class="logo">Paper<span>Thin</span></div>
        </div>
        <div class="right">
          <a href="#" class="link icon-only searchbar-enable" data-searchbar=".searchbar-wallpapers">
            <i class="icon f7-icons if-not-md">search</i>
            <i class="icon material-icons if-md">search</i>
          </a>
        </div>
        <form class="searchbar searchbar-wallpapers dark no-outline">
          <div class="searchbar-inner">
            <div class="searchbar-input-wrap">
              <input type="search" placeholder="Search wallpapers"/>
              <i class="searchbar-icon"></i>
              <span class="input-clear-button"></span>
            </div>
            <span class="searchbar-disable-button">Cancel</span>
          </div>
        </form>
      </div>
    </div>

    <!-- Searchbar overlay -->
    <div class="searchbar-overlay"></div>

    <div class="gacha-button ${gachaAnimating ? 'disabled' : ''}" @click=${triggerGacha}>
      <div class="gacha-button-content">
        <i class="icon f7-icons">sparkles</i>
        <span>Random Discovery</span>
      </div>
      <div class="gacha-button-glow"></div>
    </div>

    <div class="gacha-overlay ${gachaAnimating ? 'active' : ''}" @click=${handleOverlayClick}>
      <div class="gacha-animation" @click=${(e) => e.stopPropagation()}>
        <div class="close-button" @click=${closeGacha}>
          <i class="icon f7-icons">xmark_circle_fill</i>
        </div>
        <div class="gacha-card ${gachaRevealed ? 'revealed' : ''} ${gachaLoading ? 'loading' : ''}">
          ${gachaLoading ? $h`
            <div class="gacha-loading">
              <div class="magic-container">
                <div class="magic-circle"></div>
                <div class="magic-stars"></div>
              </div>
              <span class="loading-text">Finding your perfect wallpaper<span class="dots">...</span></span>
            </div>
          ` : gachaWallpaper && $h`
            <div class="gacha-image-container">
              <div class="magical-reveal-effect"></div>
              <img 
                class="main-image ${gachaWallpaper.loaded ? 'loaded' : ''}"
                src="${gachaWallpaper.path}"
                alt="Gacha Wallpaper"
                @load=${() => handleGachaImageLoad(gachaWallpaper)}
              />
              <div class="gacha-info">
                <h3>Discovered!</h3>
                <p>${gachaWallpaper.title || 'Mystery Wallpaper'}</p>
                <div class="gacha-provider">
                  <span>From ${gachaWallpaper.provider}</span>
                </div>
                <div class="gacha-actions">
                  <a href="#" class="view-button" @click=${() => openWallpaper(gachaWallpaper)}>
                    <i class="icon f7-icons">eye_fill</i>
                    <span>View</span>
                  </a>
                  <a href="#" class="try-again-button" @click=${tryAgain}>
                    <i class="icon f7-icons">arrow_counterclockwise</i>
                    <span>Try Again</span>
                  </a>
                </div>
              </div>
            </div>
          `}
        </div>
        ${Array.from({ length: 20 }, (_, i) => $h`
          <div class="magical-particle magical-particle-${i}"></div>
        `)}
      </div>
    </div>

    <!-- Scrollable page content-->
    <div class="page-content hide-toolbar-on-scroll ptr-content infinite-scroll-content ${selectionMode ? 'selection-mode' : ''}" 
         @ptr:refresh=${onRefresh} 
         @infinite=${loadMore}
         data-infinite-distance="50">
      
      <!-- Pull to refresh preloader -->
      <div class="ptr-preloader">
        <div class="preloader"></div>
        <div class="ptr-arrow"></div>
      </div>
      
      <!-- Wallpapers Grid -->
      <div class="wallpapers-grid" style="margin-top: 70px;">
        ${wallpapers.map((wallpaper) => $h`
          <div class="wallpaper-item elevation-2" 
               @click=${selectionMode ? () => toggleSelection(wallpaper) : () => openWallpaper(wallpaper)}
               @touchstart=${(e) => handleTouchStart(e, wallpaper)}
               @touchend=${handleTouchEnd}
               @touchmove=${handleTouchMove}>
            ${selectionMode && $h`
              <div class="selection-checkbox ${selectedWallpapers.includes(wallpaper) ? 'selected' : ''}">
                <i class="icon f7-icons">checkmark_circle_fill</i>
              </div>
            `}
            <div class="progressive-image ${wallpaper.loaded ? 'loaded' : 'skeleton-item'}">
              ${!wallpaper.loaded && $h`
                <div class="skeleton-image"></div>
                <div class="skeleton-info">
                  <div class="skeleton-resolution"></div>
                  <div class="skeleton-stats">
                    <div class="skeleton-stat"></div>
                    <div class="skeleton-stat"></div>
                  </div>
                </div>
              `}
              <img 
                class="full-image"
                src="${wallpaper.path}" 
                loading="lazy" 
                alt="${wallpaper.title}"
                @load=${() => handleImageLoad(wallpaper)}
                @error=${(e) => handleImageError(e, wallpaper)}
              />
            </div>
            <div class="wallpaper-info">
              <span class="resolution">${wallpaper.resolution}</span>
              <div class="stats">
                <span><i class="icon f7-icons">eye</i> ${wallpaper.views}</span>
                <span><i class="icon f7-icons">heart</i> ${wallpaper.favorites}</span>
              </div>
            </div>
          </div>
        `)}
        
        <!-- Virtual Skeleton Items -->
        ${Array(12).fill().map(() => $h`
          <div class="wallpaper-item skeleton-item">
            <div class="skeleton-image"></div>
            <div class="skeleton-info">
              <div class="skeleton-resolution"></div>
              <div class="skeleton-stats">
                <div class="skeleton-stat"></div>
                <div class="skeleton-stat"></div>
              </div>
            </div>
          </div>
        `)}
      </div>

      <!-- Loading spinner -->
      ${loading && $h`
        <div class="preloader infinite-scroll-preloader"></div>
      `}

      ${!loading && $store.state.isBackgroundLoading && $h`
        <div class="background-loading-indicator">
          <div class="background-loading-text">
            <span class="loading-dot">.</span>
            <span class="loading-dot">.</span>
            <span class="loading-dot">.</span>
            Loading more from other sources
          </div>
        </div>
      `}

      ${noMoreItems && $h`
        <div class="block block-strong text-align-center no-more">
          <span>You've reached the end</span>
        </div>
      `}
    </div>

    <!-- Categories -->
    <div class="categories-scrollbar dark">
      <div class="categories">
        ${categories.map((category) => $h`
          <a href="#" 
             class="category-chip ${currentCategory === category.id ? 'active' : ''}"
             data-category="${category.id}"
             @click=${() => handleCategoryClick(category.id)}>
            ${category.name}
          </a>
        `)}
      </div>
    </div>

    <!-- Selection mode toolbar -->
    ${selectionMode && $h`
      <div class="toolbar toolbar-bottom selection-toolbar">
        <div class="toolbar-inner">
          <a href="#" class="link" @click=${() => addToCollection()}>
            <i class="icon f7-icons">plus_square_fill</i>
            <span>Add to Collection</span>
          </a>
          <a href="#" class="link" @click=${() => cancelSelection()}>
            <span>Cancel</span>
          </a>
        </div>
      </div>
    `}
  </div>
</template>

<script>
export default (props, { $f7, $store, $on, $update }) => {
  let wallpapers = [];
  let loading = false;
  let page = 1;
  let noMoreItems = false;
  let searchTimeout;
  let originalWallpapers = [];
  let currentCategory = 'all';
  let selectionMode = false;
  let selectedWallpapers = [];
  let longPressTimer;
  let touchMoved = false;
  let isBackgroundLoading = false;
  let gachaAnimating = false;
  let gachaRevealed = false;
  let gachaWallpaper = null;
  let gachaLoading = false;
  
  // Define categories with proper API values
  const categories = [
    { id: 'all', name: 'All' },
    { id: 'general', name: 'General' },
    { id: 'anime', name: 'Anime' },
    { id: 'people', name: 'People' },
    { id: 'landscape', name: 'Landscape' },
    { id: 'space', name: 'Space' },
    { id: 'digital', name: 'Digital Art' },
    { id: 'minimal', name: 'Minimal' },
    { id: 'nature', name: 'Nature' },
    { id: 'cars', name: 'Cars' },
    { id: 'gaming', name: 'Gaming' },
    { id: 'technology', name: 'Technology' },
    { id: 'sketchy', name: 'ðŸ”ž Sketchy' },
    { id: 'nsfw', name: 'ðŸ”ž NSFW' }
  ];

  // Load initial wallpapers
  loadWallpapers();

  function handleGachaImageLoad(wallpaper) {
    // Mark the image as loaded to trigger fade-in animation
    wallpaper.loaded = true;
    $update();
  }

  async function handleCategoryClick(categoryId) {
    console.log('Category clicked:', categoryId); // Debug log
    
    if (currentCategory === categoryId) return;
    
    $f7.preloader.show();
    
    try {
      currentCategory = categoryId;
      page = 1;
      wallpapers = [];
      noMoreItems = false;
      $update();
      
      console.log('Fetching category:', currentCategory); // Debug log
      
      const newWallpapers = await $store.dispatch('fetchWallpapers', { 
        page,
        category: currentCategory
      });
      
      console.log('New wallpapers:', newWallpapers); // Debug log
      
      if (newWallpapers && newWallpapers.length > 0) {
        wallpapers = newWallpapers;
        originalWallpapers = [...newWallpapers];
        page += 1;
      } else {
        noMoreItems = true;
      }
    } catch (error) {
      console.error('Error loading category:', error);
      $f7.toast.show({
        text: 'Error loading category',
        closeTimeout: 2000,
      });
    } finally {
      $f7.preloader.hide();
      $update();
    }
  }

  async function loadWallpapers(reset = false) {
    if (loading || (noMoreItems && !reset)) return;
    
    loading = true;
    $update();

    try {
      if (reset) {
        page = 1;
        wallpapers = [];
        noMoreItems = false;
      }

      const newWallpapers = await $store.dispatch('fetchWallpapers', { 
        page,
        category: currentCategory === 'all' ? null : currentCategory
      });
      
      if (!newWallpapers || newWallpapers.length === 0) {
        noMoreItems = true;
      } else {
        // If resetting or first page, replace wallpapers
        if (reset || page === 1) {
          wallpapers = newWallpapers;
          originalWallpapers = [...newWallpapers];
        } else {
          // Otherwise append new wallpapers
          wallpapers = [...wallpapers, ...newWallpapers];
        }
        page += 1;
      }
    } catch (error) {
      console.error('Error in loadWallpapers:', error);
      $f7.toast.show({
        text: 'Error loading wallpapers',
        closeTimeout: 2000,
      });
    }

    loading = false;
    $update();
  }

  async function loadMore() {
    if (loading) return;
    
    loading = true;
    $update();

    try {
      const newWallpapers = await $store.dispatch('fetchWallpapers', {
        page,
        category: currentCategory === 'all' ? null : currentCategory
      });
      
      if (newWallpapers && newWallpapers.length > 0) {
        wallpapers = [...wallpapers, ...newWallpapers];
        page += 1;
      }
    } catch (error) {
      console.error('Error loading more wallpapers:', error);
    }

    loading = false;
    $update();
  }

  function onRefresh(e, done) {
    loadWallpapers(true).then(() => {
      done();
    });
  }

  function openWallpaper(wallpaper) {
    $f7.views.main.router.navigate('/wallpaper/', {
      props: {
        wallpaper
      }
    });
  }

  function handleImageLoad(wallpaper) {
    wallpaper.loaded = true;
    $update();
  }

  function handleImageError(event, wallpaper) {
    const img = event.target;
    const currentUrl = img.src;
    
    // Try next fallback URL
    const nextUrl = wallpaper.fallbackUrls.find(url => url !== currentUrl);
    if (nextUrl) {
      img.src = nextUrl;
    }
  }

  // Initialize searchbar
  $on('pageInit', () => {
    const searchbar = $f7.searchbar.create({
      el: '.searchbar-wallpapers',
      searchContainer: '.wallpapers-grid',
      searchIn: '.wallpaper-item',
      customSearch: true,
      on: {
        search(sb, query, previousQuery) {
          if (query.length > 2) {
            // Clear current wallpapers and show skeleton loading state
            wallpapers = [];
            loading = true;
            $update();
            
            // Debounce search
            if (searchTimeout) clearTimeout(searchTimeout);
            searchTimeout = setTimeout(async () => {
              try {
                const searchResults = await $store.dispatch('searchWallpapers', query);
                wallpapers = searchResults;
                page = 1;
                noMoreItems = true;
              } catch (error) {
                console.error('Search error:', error);
                $f7.toast.show({
                  text: 'Search failed. Please try again.',
                  closeTimeout: 2000,
                });
              } finally {
                loading = false;
                $update();
              }
            }, 300);
          }
        },
        clear(sb) {
          // Show loading state briefly while restoring
          loading = true;
          wallpapers = [];
          $update();
          
          // Short timeout for smooth transition
          setTimeout(() => {
            wallpapers = [...originalWallpapers];
            page = Math.ceil(wallpapers.length / 24);
            noMoreItems = false;
            loading = false;
            $update();
          }, 150);
        },
        disable() {
          // Show loading state briefly while restoring
          loading = true;
          wallpapers = [];
          $update();
          
          setTimeout(() => {
            wallpapers = [...originalWallpapers];
            page = Math.ceil(wallpapers.length / 24);
            noMoreItems = false;
            loading = false;
            $update();
          }, 150);
        }
      }
    });
  });

  // Hide navbar on scroll
  $on('pageInit', () => {
    const $pageContent = $f7.$('.page-content');
    let lastScrollTop = 0;
    
    $pageContent.on('scroll', (e) => {
      const scrollTop = e.target.scrollTop;
      const $navbar = $f7.$('.navbar');
      const $categoriesBar = $f7.$('.categories-scrollbar');
      
      if (scrollTop > lastScrollTop && scrollTop > 100) {
        // Scrolling down
        $navbar.addClass('navbar-hidden');
        $categoriesBar.addClass('categories-hidden');
      } else {
        // Scrolling up
        $navbar.removeClass('navbar-hidden');
        $categoriesBar.removeClass('categories-hidden');
      }
      
      lastScrollTop = scrollTop;
    });
  });

  // Cleanup on page leave
  $on('pageBeforeOut', () => {
    if (!infiniteScrollDetached) {
      $f7.infiniteScroll.detach('.infinite-scroll-content');
      infiniteScrollDetached = true;
    }
  });

  function enableSelectionMode(wallpaper) {
    selectionMode = true;
    selectedWallpapers = [wallpaper];
    // Hide main toolbar
    document.querySelector('.toolbar.tabbar-icons').classList.add('toolbar-hidden');
    $update();
  }

  function toggleSelection(wallpaper) {
    const index = selectedWallpapers.indexOf(wallpaper);
    if (index > -1) {
      selectedWallpapers.splice(index, 1);
    } else {
      selectedWallpapers.push(wallpaper);
    }
    if (selectedWallpapers.length === 0) {
      selectionMode = false;
    }
    $update();
  }

  async function addToCollection() {
    const collections = await $store.dispatch('fetchCollections');
    
    const buttons = [];
    
    // Add existing collections
    if (collections.length > 0) {
      buttons.push(...collections.map(c => ({
        text: c.name,
        onClick: async () => {
          $f7.preloader.show();
          try {
            await $store.dispatch('addToCollection', {
              collectionId: c.id,
              wallpapers: selectedWallpapers
            });
            
            // Force update collections in store
            await $store.dispatch('fetchCollections');
            
            $f7.toast.show({
              text: 'Added to collection',
              position: 'bottom',
              closeTimeout: 2000
            });
            
            // Emit an event to notify collections page
            window.dispatchEvent(new CustomEvent('collectionsUpdated'));
            
            cancelSelection();
          } catch (error) {
            $f7.toast.show({
              text: 'Failed to add to collection',
              position: 'bottom',
              closeTimeout: 2000
            });
          }
          $f7.preloader.hide();
        }
      })));
      
      buttons.push({ text: '', label: true });
    }
    
    // Add "New Collection" button with similar updates
    buttons.push({
      text: '<span class="color-primary">New Collection</span>',
      bold: true,
      onClick: () => {
        $f7.dialog.create({
          title: 'New Collection',
          text: 'Enter collection name',
          content: `
            <div class="dialog-input-field">
              <input type="text" class="dialog-input" placeholder="Collection name">
            </div>
          `,
          buttons: [
            {
              text: 'Cancel'
            },
            {
              text: 'Create',
              bold: true,
              onClick: async (dialog) => {
                const name = dialog.$el.find('.dialog-input').val();
                if (!name.trim()) return;
                
                $f7.preloader.show();
                try {
                  const collection = await $store.dispatch('createCollection', { name });
                  await $store.dispatch('addToCollection', {
                    collectionId: collection.id,
                    wallpapers: selectedWallpapers
                  });
                  
                  // Force update collections in store
                  await $store.dispatch('fetchCollections');
                  
                  // Emit update event
                  window.dispatchEvent(new CustomEvent('collectionsUpdated'));
                  
                  $f7.toast.show({
                    text: 'Created collection and added wallpapers',
                    position: 'bottom',
                    closeTimeout: 2000
                  });
                  cancelSelection();
                } catch (error) {
                  $f7.toast.show({
                    text: 'Failed to create collection',
                    position: 'bottom',
                    closeTimeout: 2000
                  });
                }
                $f7.preloader.hide();
              }
            }
          ]
        }).open();
      }
    });

    // Show actions sheet
    $f7.actions.create({
      buttons: [buttons],
      closeOnSelect: true,
      animate: true
    }).open();
  }

  function cancelSelection() {
    selectionMode = false;
    selectedWallpapers = [];
    // Show main toolbar
    document.querySelector('.toolbar.tabbar-icons').classList.remove('toolbar-hidden');
    $update();
  }

  function handleTouchStart(e, wallpaper) {
    touchMoved = false;
    longPressTimer = setTimeout(() => {
      if (!touchMoved) {
        enableSelectionMode(wallpaper);
        // Add haptic feedback if available
        if (window.navigator && window.navigator.vibrate) {
          window.navigator.vibrate(50);
        }
      }
    }, 500); // 500ms for long press
  }

  function handleTouchEnd() {
    clearTimeout(longPressTimer);
  }

  function handleTouchMove() {
    touchMoved = true;
    clearTimeout(longPressTimer);
  }

  function initializeAnimations() {
    const wallpaperItems = document.querySelectorAll('.wallpaper-item');
    
    // Initialize intersection observer for fade-in effects
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.style.opacity = '1';
          entry.target.style.transform = 'translateY(0)';
        }
      });
    }, { threshold: 0.1 });

    wallpaperItems.forEach(item => {
      item.style.opacity = '0';
      item.style.transform = 'translateY(20px)';
      item.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
      observer.observe(item);
    });
  }

  $on('pageInit', () => {
    initializeAnimations();
    // ... existing pageInit code ...
  });

  // Update the wallpaper update listener
  $on('pageInit', () => {
    window.addEventListener('wallpapersUpdated', () => {
      const newWallpapers = $store.state.wallpapers;
      // Merge new wallpapers with existing ones, avoiding duplicates
      wallpapers = mergeWallpapers(wallpapers, newWallpapers);
      $update();
    });
  });

  // Helper function to merge wallpapers avoiding duplicates
  function mergeWallpapers(existing, newOnes) {
    const existingIds = new Set(existing.map(w => w.id));
    const uniqueNew = newOnes.filter(w => !existingIds.has(w.id));
    return [...existing, ...uniqueNew];
  }

  // Cleanup listener
  $on('pageBeforeRemove', () => {
    window.removeEventListener('wallpapersUpdated', () => {});
  });

  // Separate function for getting new wallpaper
  async function getNewWallpaper() {
    gachaRevealed = false;
    gachaLoading = true;
    $update();

    try {
      const randomWallpaper = await $store.dispatch('fetchRandomWallpaper');
      gachaWallpaper = randomWallpaper;
      gachaLoading = false;
      
      // Reveal the card after a short delay
      setTimeout(() => {
        gachaRevealed = true;
        $update();
      }, 500);
    } catch (error) {
      console.error('Gacha error:', error);
      $f7.toast.show({
        text: 'Failed to get random wallpaper',
        closeTimeout: 2000,
      });
    }
  }

  // Update triggerGacha to use getNewWallpaper
  async function triggerGacha() {
    if (gachaAnimating) return;
    
    gachaAnimating = true;
    $update();
    
    await getNewWallpaper();
  }

  // Update the template's try-again button click handler
  function tryAgain(e) {
    e.preventDefault();
    getNewWallpaper();
  }

  // Keep closeGacha for overlay and close button
  function closeGacha() {
    gachaAnimating = false;
    gachaRevealed = false;
    gachaLoading = false;
    
    // Wait for the overlay fade-out animation before clearing the wallpaper
    setTimeout(() => {
      gachaWallpaper = null;
      $update();
    }, 300);
    
    $update();
  }

  function handleOverlayClick(e) {
    if (e.target.classList.contains('gacha-overlay')) {
      closeGacha();
    }
  }

  function onGachaAnimationEnd() {
    if (!gachaRevealed) {
      gachaRevealed = true;
      $update();
    }
  }

  function handleGachaImageError(event, wallpaper) {
    const img = event.target;
    const currentSrc = img.src;
    
    // Try fallback URLs if available
    if (wallpaper.fallbackUrls && wallpaper.fallbackUrls.length > 0) {
      const nextUrl = wallpaper.fallbackUrls.find(url => url !== currentSrc);
      if (nextUrl) {
        img.src = nextUrl;
        return;
      }
    }
    
    // If all fallbacks fail, use a placeholder
    img.src = 'path/to/your/placeholder-image.jpg';
  }

  function handleGachaPreload(wallpaper) {
    // Create a new image to preload the full version
    const fullImg = new Image();
    
    fullImg.onload = () => {
      // Once full version is loaded, update the main image
      const mainImage = document.querySelector('.gacha-card .main-image');
      if (mainImage) {
        mainImage.src = fullImg.src;
        wallpaper.loaded = true;
        $update();
      }
    };

    // Start loading the full version
    if (wallpaper.fullUrl) {
      fullImg.src = wallpaper.fullUrl;
    }
  }

  function handleButtonHover(e) {
    const button = e.currentTarget;
    const rect = button.getBoundingClientRect();
    const x = ((e.clientX - rect.left) / rect.width) * 100;
    const y = ((e.clientY - rect.top) / rect.height) * 100;
    button.style.setProperty('--x', `${x}%`);
    button.style.setProperty('--y', `${y}%`);
  }

  $on('pageInit', () => {
    const gachaButton = document.querySelector('.gacha-button');
    if (gachaButton) {
      gachaButton.addEventListener('mousemove', handleButtonHover);
    }
  });

  $on('pageBeforeRemove', () => {
    const gachaButton = document.querySelector('.gacha-button');
    if (gachaButton) {
      gachaButton.removeEventListener('mousemove', handleButtonHover);
    }
  });

  return $render;
}
</script>

<style>
:root {
  --f7-navbar-bg-color: #ffffff;
  --f7-navbar-height: 60px;
}

.navbar {
  backdrop-filter: blur(15px);
  -webkit-backdrop-filter: blur(15px);
  box-shadow: 0 4px 30px rgba(0, 0, 0, 0.05);
}

.navbar .logo {
  font-size: 22px;
  background: linear-gradient(135deg, var(--f7-theme-color), #ff6b6b);
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  letter-spacing: -0.5px;
}

.categories-scrollbar {
  position: fixed;
  bottom: var(--f7-toolbar-height);
  left: 0;
  right: 0;
  z-index: 600;
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  padding: 12px 0;
}

.categories {
  padding: 0 16px;
  margin: 0;
  display: flex;
  gap: 10px;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
  scrollbar-width: none;
  -ms-overflow-style: none;
  scroll-behavior: smooth;
}

.categories::-webkit-scrollbar {
  display: none;
}

.category-chip {
  padding: 8px 16px;
  border-radius: 100px;
  margin: 0 6px;
  font-size: 14px;
  font-weight: 500;
  transition: all 0.2s ease;
}

.category-chip.active {
  background: var(--f7-theme-color);
  color: #fff;
}

.wallpapers-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 16px;
  padding: 16px;
  margin: 0;
  padding-top: 70px;
  padding-bottom: calc(var(--f7-toolbar-height) + 68px);
}

.wallpaper-item {
  position: relative;
  border-radius: 16px;
  overflow: hidden;
  aspect-ratio: 9/16;
  background: #f5f5f5;
  transition: transform 0.2s ease;
  box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
  transform-origin: center;
  will-change: transform;
}

.wallpaper-item:active {
  transform: scale(0.98);
}

.wallpaper-item:hover {
  transform: translateY(-4px);
  box-shadow: 0 12px 25px rgba(0, 0, 0, 0.15);
}

.wallpaper-item img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.wallpaper-info {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 20px 16px 16px;
  background: linear-gradient(to top, 
    rgba(0, 0, 0, 0.8) 0%, 
    rgba(0, 0, 0, 0.4) 50%,
    transparent 100%
  );
  color: #fff;
  font-size: 12px;
  opacity: 1;
  transition: opacity 0.2s ease;
}

.wallpaper-item:hover .wallpaper-info {
  opacity: 1;
}

.wallpaper-info .resolution {
  font-weight: 500;
}

.wallpaper-info .stats {
  display: flex;
  gap: 12px;
  margin-top: 4px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 8px;
  padding: 6px 10px;
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);
}

.wallpaper-info .stats span {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  border-radius: 6px;
  transition: background 0.2s ease;
}

.wallpaper-info .stats span:hover {
  background: rgba(255, 255, 255, 0.1);
}

.wallpaper-info .stats i {
  font-size: 14px;
}

.no-more {
  color: #666;
  font-size: 14px;
  margin-top: 20px;
}

.infinite-scroll-preloader {
  position: relative;
  padding: 20px;
}

.infinite-scroll-preloader:before {
  content: '';
  position: absolute;
  inset: 0;
  background: radial-gradient(circle at center,
    rgba(var(--f7-theme-color-rgb), 0.1),
    transparent 70%
  );
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0% { transform: scale(0.8); }
  50% { transform: scale(1.2); }
  100% { transform: scale(1); }
}

.searchbar {
  display: none; /* Hide by default */
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
  background: #fff;
  z-index: 200;
}

.searchbar.searchbar-enabled {
  display: block;
}

.searchbar-overlay {
  display: none;
  position: fixed;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.4);
  z-index: 100;
  animation: fadeIn 0.2s ease;
}

.searchbar-enabled ~ .searchbar-overlay {
  display: block;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@media (max-width: 480px) {
  .wallpapers-grid {
    grid-template-columns: repeat(2, 1fr);
    gap: 12px;
    padding: 12px;
  }
  
  .wallpaper-info {
    font-size: 11px;
    padding: 15px 12px 12px;
  }
  
  .category-chip {
    padding: 8px 14px;
    font-size: 13px;
  }
}

.progressive-image {
  position: relative;
  width: 100%;
  height: 100%;
  overflow: hidden;
}

.progressive-image .placeholder {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  filter: blur(10px);
  transform: scale(1.1);
  transition: opacity 0.3s ease;
}

.progressive-image .full-image {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  opacity: 0;
  transition: opacity 0.3s ease;
}

.progressive-image.loaded .placeholder {
  opacity: 0;
}

.progressive-image.loaded .full-image {
  opacity: 1;
}

.navbar, .categories-scrollbar {
  transition: transform 0.3s ease;
}

.navbar.navbar-hidden {
  transform: translateY(-100%);
}

.categories-scrollbar {
  position: sticky;
  top: var(--f7-navbar-height);
  z-index: 100;
  transition: transform 0.3s ease;
}

.categories-scrollbar.categories-hidden {
  transform: translateY(calc(100% + var(--f7-toolbar-height) + 8px));
}

.category-chip {
  padding: 8px 16px;
  border-radius: 100px;
  background: #f5f5f5;
  color: #666;
  font-size: 14px;
  white-space: nowrap;
  transition: all 0.3s ease;
  margin: 0 4px;
  text-decoration: none;
}

.category-chip.active {
  background: var(--f7-theme-color);
  color: #fff;
  font-weight: 500;
}

.page-content {
  padding-top: 0 !important;
}

.category-chip[data-category="sketchy"],
.category-chip[data-category="nsfw"] {
  background: #ff4b3e15;
  color: #ff4b3e;
}

.category-chip[data-category="sketchy"].active,
.category-chip[data-category="nsfw"].active {
  background: #ff4b3e;
  color: white;
}

.selection-checkbox {
  position: absolute;
  top: 8px;
  right: 8px;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.9);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2;
  transform: scale(0);
  opacity: 0;
  transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.selection-checkbox i {
  font-size: 24px;
  color: var(--f7-theme-color);
  opacity: 0;
  transition: opacity 0.2s ease;
}

.selection-checkbox.selected i {
  opacity: 1;
}

/* Add a subtle overlay when in selection mode */
.wallpaper-item {
  position: relative;
}

.wallpaper-item::after {
  content: '';
  position: absolute;
  inset: 0;
  background: rgba(0, 0, 0, 0.2);
  opacity: 0;
  transition: opacity 0.2s ease;
}

/* New class for selection mode */
.selection-mode .wallpaper-item::after {
  opacity: 1;
}

/* Add this CSS for the selection toolbar */
.toolbar.selection-toolbar {
  z-index: 6000; /* Higher than the main toolbar */
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  background: rgba(255, 255, 255, 0.9);
  border-top: none;
  padding-bottom: env(safe-area-inset-bottom);
}

/* Dark Mode Support */
:root.theme-dark {
  --f7-navbar-bg-color: rgba(20, 20, 20, 0.95);
  --f7-searchbar-bg-color: rgba(30, 30, 30, 0.9);
  
  .searchbar-inner {
    background: rgba(30, 30, 30, 0.9);
  }

  .searchbar-input {
    background-color: rgba(30, 30, 30, 0.9);
    color: rgba(255, 255, 255, 0.9);
  }

  .wallpaper-item {
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
    background: #1c1c1c;
  }
  
  .category-chip {
    background: rgba(255, 255, 255, 0.1);
    color: rgba(255, 255, 255, 0.8);
    border: 1px solid rgba(255, 255, 255, 0.05);
  }
  
  .categories-scrollbar {
    background: linear-gradient(to bottom,
      rgba(20, 20, 20, 0.95),
      rgba(20, 20, 20, 0.9)
    );
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
  }

  .toolbar.toolbar-bottom,
  .selection-toolbar {
    background: rgba(20, 20, 20, 0.95);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-top: 1px solid rgba(255, 255, 255, 0.05);
  }

  .wallpaper-info {
    background: rgba(20, 20, 20, 0.9);
    color: rgba(255, 255, 255, 0.9);
  }

  .stats {
    color: rgba(255, 255, 255, 0.7);
  }

  .page {
    background-color: #121212;
  }
}

.provider-badge {
  position: absolute;
  top: 8px;
  left: 8px;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 10px;
  font-weight: 500;
  text-transform: uppercase;
  background: rgba(0, 0, 0, 0.5);
  color: #fff;
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);
}

.provider-badge.wallhaven { background: rgba(255, 75, 62, 0.8); }
.provider-badge.unsplash { background: rgba(0, 0, 0, 0.8); }
.provider-badge.bing { background: rgba(32, 120, 244, 0.8); }
.provider-badge.alphacoders { background: rgba(138, 43, 226, 0.8); }

/* Skeleton Loading Styles */
.skeleton-item {
  background: #f5f5f5;
  position: relative;
  overflow: hidden;
}

.skeleton-image {
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
  background-size: 200% 100%;
  animation: shimmer 1.5s infinite;
}

.skeleton-info {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 16px;
  background: rgba(245, 245, 245, 0.9);
}

.skeleton-resolution {
  width: 60px;
  height: 12px;
  background: #e0e0e0;
  border-radius: 4px;
  margin-bottom: 8px;
}

.skeleton-stats {
  display: flex;
  gap: 12px;
}

.skeleton-stat {
  width: 40px;
  height: 12px;
  background: #e0e0e0;
  border-radius: 4px;
}

@keyframes shimmer {
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
}

/* Dark mode support */
:root.theme-dark {
  .skeleton-item {
    background: #2c2c2c;
  }
  
  .skeleton-image {
    background: linear-gradient(90deg, #333 25%, #3a3a3a 50%, #333 75%);
  }
  
  .skeleton-info {
    background: rgba(44, 44, 44, 0.9);
  }
  
  .skeleton-resolution,
  .skeleton-stat {
    background: #3a3a3a;
  }
}

.background-loading-indicator {
  text-align: center;
  padding: 16px;
  color: #666;
  font-size: 14px;
  opacity: 0.8;
}

.background-loading-text {
  display: inline-flex;
  align-items: center;
  gap: 2px;
}

.loading-dot {
  animation: loadingDots 1.4s infinite;
  opacity: 0.5;
}

.loading-dot:nth-child(2) {
  animation-delay: 0.2s;
}

.loading-dot:nth-child(3) {
  animation-delay: 0.4s;
}

@keyframes loadingDots {
  0%, 100% { opacity: 0.2; }
  50% { opacity: 1; }
}

:root.theme-dark {
  .background-loading-indicator {
    color: #999;
  }
}

.skeleton-item {
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0% { opacity: 1; }
  50% { opacity: 0.5; }
  100% { opacity: 1; }
}

.progressive-image.skeleton-item {
  background: #f5f5f5;
}

:root.theme-dark {
  .progressive-image.skeleton-item {
    background: #2c2c2c;
  }
}

/* Dark Mode Overrides */
:root.theme-dark {
  .categories-scrollbar {
    background: linear-gradient(to bottom,
      rgba(20, 20, 20, 0.95),
      rgba(20, 20, 20, 0.8)
    );
  }

  .category-chip {
    background: rgba(255, 255, 255, 0.1);
    color: rgba(255, 255, 255, 0.8);
    border: 1px solid rgba(255, 255, 255, 0.05);
  }

  .category-chip.active {
    background: var(--f7-theme-color);
    color: #fff;
    border-color: var(--f7-theme-color);
  }

  .toolbar {
    background: rgba(20, 20, 20, 0.9);
    border-top: 1px solid rgba(255, 255, 255, 0.05);
  }

  .toolbar-inner a {
    color: rgba(255, 255, 255, 0.8);
  }

  .selection-toolbar {
    background: rgba(20, 20, 20, 0.9);
  }
}

.selection-mode .wallpaper-item .selection-checkbox {
  transform: scale(1);
  opacity: 1;
}

.selection-mode .wallpaper-item {
  position: relative;
}

.selection-mode .wallpaper-item::after {
  content: '';
  position: absolute;
  inset: 0;
  background: rgba(0, 0, 0, 0.3);
  z-index: 1;
  pointer-events: none;
}

.selection-checkbox {
  position: absolute;
  top: 8px;
  right: 8px;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.9);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2;
  transform: scale(0);
  opacity: 0;
  transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.gacha-button {
  position: fixed;
  bottom: calc(var(--f7-toolbar-height) + 80px);
  right: 16px;
  background: var(--f7-theme-color);
  color: #fff;
  padding: 16px 24px;
  border-radius: 100px;
  z-index: 100;
  overflow: hidden;
  box-shadow: 0 4px 15px rgba(var(--f7-theme-color-rgb), 0.3);
  transition: all 0.3s ease;
}

.gacha-button-content {
  position: relative;
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 16px;
  font-weight: 500;
  z-index: 1;
}

.gacha-button-content i {
  font-size: 20px;
}

.gacha-button-glow {
  position: absolute;
  inset: 0;
  background: radial-gradient(
    circle at var(--x, 50%) var(--y, 50%),
    rgba(255, 255, 255, 0.3) 0%,
    rgba(255, 255, 255, 0) 60%
  );
  opacity: 0;
  transition: opacity 0.3s ease;
}

.gacha-button:hover .gacha-button-glow {
  opacity: 1;
}

.gacha-button:active {
  transform: scale(0.95);
}

.gacha-button.disabled {
  opacity: 0.5;
  pointer-events: none;
}

.gacha-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.9);
  z-index: 5000;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease;
}

.gacha-overlay.active {
  opacity: 1;
  pointer-events: auto;
}

.gacha-animation {
  position: relative;
  width: 90vw;
  max-width: 400px;
  aspect-ratio: 2/3;
}

.gacha-card {
  position: relative;
  width: 100%;
  height: 100%;
  background: #1c1c1c;
  border-radius: 20px;
  overflow: hidden;
  box-shadow: 0 0 50px rgba(var(--f7-theme-color-rgb), 0.3);
  transform: scale(0.8);
  opacity: 0;
  transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1),
              opacity 0.6s ease;
}

.gacha-card.loading {
  opacity: 1;
  transform: scale(1);
  animation: floatCard 2s ease-in-out infinite;
}

.gacha-card.revealed {
  opacity: 1;
  transform: scale(1);
}

.gacha-loading {
  position: absolute;
  inset: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 20px;
  color: #fff;
}

.magic-container {
  position: relative;
  width: 80px;
  height: 80px;
  margin-bottom: 20px;
}

.magic-circle {
  position: absolute;
  inset: 0;
  border: 2px solid var(--f7-theme-color);
  border-radius: 50%;
  animation: rotateMagic 4s linear infinite;
}

.magic-circle::before {
  content: '';
  position: absolute;
  inset: -5px;
  border: 1px solid var(--f7-theme-color);
  border-radius: 50%;
  opacity: 0.5;
}

.magic-stars {
  position: absolute;
  inset: -10px;
  animation: rotateStars 8s linear infinite;
}

.magic-stars::before {
  content: 'âœ¦';
  position: absolute;
  font-size: 16px;
  color: var(--f7-theme-color);
  animation: twinkle 1.5s ease-in-out infinite;
}

.magical-reveal-effect {
  position: absolute;
  inset: 0;
  background: linear-gradient(45deg,
    transparent 0%,
    rgba(255, 255, 255, 0.8) 50%,
    transparent 100%
  );
  transform: translateX(-100%);
  animation: revealSweep 1s ease-out forwards;
}

.magic-runes {
  position: absolute;
  inset: 0;
  pointer-events: none;
}

.magic-rune {
  position: absolute;
  width: 60px;
  height: 60px;
  border: 2px solid var(--f7-theme-color);
  opacity: 0;
  transform: rotate(0deg) scale(0);
}

.rune-0 {
  top: -30px;
  left: 20%;
  animation: runeFloat 3s ease-in-out infinite, runeAppear 0.5s ease-out forwards;
}

.rune-1 {
  bottom: -20px;
  right: 25%;
  animation: runeFloat 3s ease-in-out infinite 0.3s, runeAppear 0.5s ease-out 0.2s forwards;
}

.rune-2 {
  top: 40%;
  right: -20px;
  animation: runeFloat 3s ease-in-out infinite 0.6s, runeAppear 0.5s ease-out 0.4s forwards;
}

.loading-text {
  color: #fff;
  font-size: 16px;
  font-weight: 500;
}

.dots {
  animation: loadingDots 1.4s infinite;
}

@keyframes rotateMagic {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

@keyframes rotateStars {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(-360deg); }
}

@keyframes twinkle {
  0%, 100% { opacity: 0.2; transform: scale(0.8); }
  50% { opacity: 1; transform: scale(1.2); }
}

@keyframes revealSweep {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

@keyframes runeFloat {
  0%, 100% { transform: rotate(0deg) translateY(0); }
  50% { transform: rotate(180deg) translateY(-10px); }
}

@keyframes runeAppear {
  0% { opacity: 0; transform: scale(0); }
  100% { opacity: 0.6; transform: scale(1); }
}

.magical-particle {
  position: absolute;
  width: 4px;
  height: 4px;
  background: var(--f7-theme-color);
  border-radius: 50%;
  filter: blur(1px);
  pointer-events: none;
  opacity: 0;
}

.gacha-card.loading ~ .magical-particle {
  animation: particleMagic 1.5s ease-out infinite;
}

@keyframes particleMagic {
  0% {
    opacity: 0;
    transform: translate(var(--tx, 0), var(--ty, 0)) scale(0);
  }
  50% {
    opacity: 0.8;
    transform: translate(
      calc(var(--tx, 0) * 1.2),
      calc(var(--ty, 0) * 1.2)
    ) scale(1);
  }
  100% {
    opacity: 0;
    transform: translate(
      calc(var(--tx, 0) * 1.5),
      calc(var(--ty, 0) * 1.5)
    ) scale(0);
  }
}

/* Generate more varied particles */
${Array.from({ length: 20 }, (_, i) => `
.magical-particle-${i} {
  left: ${50 + Math.cos(i * Math.PI/10) * 100}%;
  top: ${50 + Math.sin(i * Math.PI/10) * 100}%;
  --tx: ${Math.cos(i * Math.PI/10) * 50}px;
  --ty: ${Math.sin(i * Math.PI/10) * 50}px;
  animation-delay: ${i * 0.1}s;
}`).join('\n')}

.close-button {
  position: absolute;
  top: -50px;
  right: 0;
  width: 44px;
  height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: rgba(255, 255, 255, 0.8);
  z-index: 1;
  cursor: pointer;
}

.close-button i {
  font-size: 28px;
}

.gacha-image-container {
  position: relative;
  width: 100%;
  height: 100%;
  overflow: hidden;
}

.gacha-image-container .main-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
  opacity: 0;
  transition: opacity 0.3s ease;
}

.gacha-image-container .main-image.loaded {
  opacity: 1;
}

.gacha-info {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 20px;
  background: linear-gradient(to top,
    rgba(0, 0, 0, 0.9) 0%,
    rgba(0, 0, 0, 0.7) 50%,
    transparent 100%
  );
  color: #fff;
  text-align: center;
}

.gacha-info h3 {
  margin: 0 0 8px 0;
  font-size: 24px;
  font-weight: 600;
}

.gacha-info p {
  margin: 0 0 8px 0;
  font-size: 16px;
  opacity: 0.9;
}

.gacha-provider {
  margin-bottom: 16px;
  font-size: 14px;
  opacity: 0.7;
}

.gacha-actions {
  display: flex;
  gap: 16px;
  justify-content: center;
  margin-top: 20px;
}

.gacha-actions a {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 24px;
  border-radius: 100px;
  text-decoration: none;
  color: #fff;
  font-size: 16px;
  font-weight: 500;
  transition: all 0.3s ease;
}

.gacha-actions a:hover {
  transform: translateY(-2px);
}

.gacha-actions a:active {
  transform: scale(0.95);
}

.view-button {
  background: var(--f7-theme-color);
  box-shadow: 0 4px 15px rgba(var(--f7-theme-color-rgb), 0.3);
}

.try-again-button {
  background: rgba(255, 255, 255, 0.2);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
}

.gacha-actions i {
  font-size: 20px;
}
</style>